syntax = "proto3";

package woodstock;

enum StatusCode {
  Ok = 0;
  Failed = 1;
}

message FileManifest {
  message FileManifestStat {
    int64 ownerId = 1;
    int64 groupId = 2;
    int64 size = 3;
    int64 lastRead = 4;
    int64 lastModified = 5;
    int64 created = 6;
    int64 mode = 7;
  }

  message FileManifestAcl {
    string user = 1;
    string group = 2;
    int32 mask = 3;
    int32 other = 4;
  }

  bytes path = 1;
  FileManifestStat stats = 2;
  map<string, bytes> xattr = 5;
  repeated FileManifestAcl acl = 6;
  repeated bytes chunks = 3;
  bytes sha256 = 4;
}

message FileManifestJournalEntry {
  enum EntryType {
    // Add a new file
    ADD = 0;
    // Modify a file
    MODIFY = 1;
    // Remove a file
    REMOVE = 2;
    // End of backup
    CLOSE = 255;
  }

  oneof entry {
    FileManifest manifest = 1;
    bytes path = 2;
  }
  EntryType type = 3;
}

message LogEntry {
  enum LogLevel {
    DEBUG = 0;
    INFO = 1;
    WARN = 2;
    ERROR = 3;
    FATAL = 4;
  }

  LogLevel level = 1;
  string line = 2;
}

message FileChunk {
  bytes data = 1;
}

message BackupShare {
  bytes sharePath = 1;
  repeated bytes includes = 2;
  repeated bytes excludes = 3;
}

message PrepareBackupRequest {
  BackupShare share = 1;
  uint32 lastBackupNumber = 2;
  uint32 newBackupNumber = 3;
}

message PrepareBackupReply {
  StatusCode code = 1;
  bool needRefreshCache = 2;
}

message RefreshCacheReply {
  StatusCode code = 1;
}

message LaunchBackupRequest {
  BackupShare share = 1;
  uint32 lastBackupNumber = 2;
  uint32 newBackupNumber = 3;
}

message GetChunkRequest {
  bytes filename = 1;
  uint64 position = 2;
  uint64 size = 3;
  bytes sha256 = 4;
}

message StreamLogRequest {

}

message UpdateManifestReply {
  StatusCode code = 1;
}

message ExecuteCommandRequest {
  string command = 1;
}

message ExecuteCommandReply {
  int32 code = 1;
  string stdout = 2;
  string stderr = 3;
}

service WoodstockClientService {
  // 0. Execute a command directly on the client
  rpc ExecuteCommand(ExecuteCommandRequest) returns (ExecuteCommandReply) {}

  // 1. Server want to start a backup session and send the configuration and last backup number.
  //    If the client has no previous cache, the client ask for more information.
  rpc PrepareBackup(PrepareBackupRequest) returns (PrepareBackupReply) {}

  // 2. The client want a cache refresh, the server will send the new cache for the last backup
  //    number. (the backup number referenced previously)
  rpc RefreshCache(stream FileManifest) returns (RefreshCacheReply) {}

  // 3. The server launch the backup with a new number. The client will browse the client computer
  //    and will send all new file to the server
  rpc LaunchBackup(LaunchBackupRequest) returns (stream FileManifestJournalEntry) {}

  // 3bis. The server send modified manifest to the client
  rpc UpdateFileManifest(stream FileManifestJournalEntry) returns (UpdateManifestReply) {}

  // 4. When the server receive a journal entry, the server will compare the chunk with the manifest
  //    and ask all necessary chunk to the client.
  rpc GetChunk(GetChunkRequest) returns (stream FileChunk) {}

  // In parallele, the server will open a stream for the client to send log file.
  rpc StreamLog(StreamLogRequest) returns (stream LogEntry) {}
}
