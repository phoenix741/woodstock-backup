// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`BackupContext #RefreshCache #RefreshCache should create error: RefreshCacheReply 1`] = `
Object {
  "code": 1,
  "message": "Should be return error",
}
`;

exports[`BackupContext #RefreshCache #RefreshCache should create error: deleteManifest 1`] = `
[MockFunction] {
  "calls": Array [
    Array [
      Manifest {
        "journalPath": "/tmp/backups.%2Fhome.journal",
        "lockPath": "/tmp/backups.%2Fhome.lock",
        "manifestPath": "/tmp/backups.%2Fhome.manifest",
        "newPath": "/tmp/backups.%2Fhome.new",
        "path": "/tmp/",
      },
    ],
  ],
  "results": Array [
    Object {
      "type": "return",
      "value": Promise {},
    },
  ],
}
`;

exports[`BackupContext #RefreshCache #RefreshCache should create one manifest from scratch : RefreshCacheReply 1`] = `
Object {
  "code": 0,
}
`;

exports[`BackupContext #RefreshCache #RefreshCache should create one manifest from scratch : deleteManifest 1`] = `
[MockFunction] {
  "calls": Array [
    Array [
      Manifest {
        "journalPath": "/tmp/backups.%2Fhome.journal",
        "lockPath": "/tmp/backups.%2Fhome.lock",
        "manifestPath": "/tmp/backups.%2Fhome.manifest",
        "newPath": "/tmp/backups.%2Fhome.new",
        "path": "/tmp/",
      },
    ],
  ],
  "results": Array [
    Object {
      "type": "return",
      "value": Promise {},
    },
  ],
}
`;

exports[`BackupContext #RefreshCache #RefreshCache should create two manifest from scratch : RefreshCacheReply 1`] = `
Object {
  "code": 0,
}
`;

exports[`BackupContext #RefreshCache #RefreshCache should create two manifest from scratch : deleteManifest 1`] = `
[MockFunction] {
  "calls": Array [
    Array [
      Manifest {
        "journalPath": "/tmp/backups.%2Fhome.journal",
        "lockPath": "/tmp/backups.%2Fhome.lock",
        "manifestPath": "/tmp/backups.%2Fhome.manifest",
        "newPath": "/tmp/backups.%2Fhome.new",
        "path": "/tmp/",
      },
    ],
    Array [
      Manifest {
        "journalPath": "/tmp/backups.%2Fetc.journal",
        "lockPath": "/tmp/backups.%2Fetc.lock",
        "manifestPath": "/tmp/backups.%2Fetc.manifest",
        "newPath": "/tmp/backups.%2Fetc.new",
        "path": "/tmp/",
      },
    ],
  ],
  "results": Array [
    Object {
      "type": "return",
      "value": Promise {},
    },
    Object {
      "type": "return",
      "value": Promise {},
    },
  ],
}
`;

exports[`BackupContext #getChunk download a file, piece of file: getChunk 1`] = `
Array [
  "nternalServerErrorException, L",
]
`;

exports[`BackupContext #getChunk download a file: getChunk 1`] = `
Array [
  "import { InternalServerErrorException, Logger } from '@nestjs/common';
import {
  ChunkInformation,
  FileChunk,
  FileHashReader,
  FileManifest,
  FileReader,
  globStringToRegex,
  LaunchBackupReply,
  mangle,
  Manifest,
  ManifestService,
  notUndefined,
  RefreshCacheReply,
  RefreshCacheRequest,
  Share,
  StatusCode,
} from '@woodstock/shared';
import { createReadStream, ReadStream } from 'fs';
import { throwIfAborted } from 'ix/aborterror';
import { AsyncIterableX, concat, create, from, of, pipe } from 'ix/asynciterable';
import { catchError, concatAll, filter, finalize, map, wrapWithAbort } from 'ix/asynciterable/operators';
import { pipeline } from 'stream';

class CreateManifestAsyncIterable extends AsyncIterableX<FileManifest> {
  private _source: AsyncIterable<RefreshCacheRequest>;
  public lastFileManifest?: FileManifest;
  public lastHeader?: RefreshCacheRequest['header'];

  constructor(private firstManifest: FileManifest, source: AsyncIterable<RefreshCacheRequest>) {
    super();
    this._source = source;
  }

  async *[Symbol.asyncIterator](signal?: AbortSignal) {
    throwIfAborted(signal);
    if (this.firstManifest) {
      yield this.firstManifest;
    }

    const it = wrapWithAbort(this._source, signal);
    let nextIt: IteratorResult<RefreshCacheRequest, RefreshCacheRequest>;
    do {
      nextIt = await it[Symbol.asyncIterator]().next();
      if (nextIt.done) {
        break;
      }

      const { header, fileManifest } = nextIt.value;
      if (fileManifest) {
        yield fileManifest;
      }
      if (header && header.sharePath) {
        this.lastHeader = header;
        this.lastFileManifest = fileManifest;
        break;
      }
    } while (!nextIt.done);
  }
}

export class BackupContext {
  private logger = new Logger(BackupContext.name);

  constructor(private fileReader: FileReader, private manifestService: ManifestService) {}

  private async createManifestForSharePath(sharePath: Buffer, source: AsyncIterable<FileManifest>) {
    const manifest = new Manifest(\`backups.\${mangle(sharePath)}\`, '/tmp/');
    await this.manifestService.deleteManifest(manifest);

    const entries$ = pipe(
      source,
      notUndefined<FileManifest>(),
      map((fileManifest) => this.manifestService.toAddJournalEntry(fileManifest, true)),
    );
    await this.manifestService.writeJournalEntry(entries$, manifest);

    await this.manifestService.compact(manifest);
  }

  private async createManifestsFromSource(request: AsyncIterableX<RefreshCacheRequest>) {
    // First search the first header
    const it = request[Symbol.asyncIterator]();
    let next: IteratorResult<RefreshCacheRequest, RefreshCacheRequest>;
    let sharePath: Buffer;
    let firstManifest: FileManifest;

    while (!(next = await it.next()).done) {
      const { header, fileManifest } = next.value;
      sharePath = header?.sharePath;
      firstManifest = fileManifest;
      if (sharePath) {
        break;
      }
    }

    while (!next.done) {
      // Then create an iterator for the rest
      const dataIt = create<FileManifest>((signal) => {
        return {
          async next() {
            throwIfAborted(signal);

            next = await it.next();
            if (next.done) {
              return { done: true, value: undefined };
            }
            const { header, fileManifest } = next.value;
            if (header?.sharePath) {
              sharePath = header.sharePath;
              firstManifest = fileManifest;
              return { done: true, value: undefined };
            }
            return { value: fileManifest };
          },
        };
      });

      // Then create the manifest

      await this.createManifestForSharePath(sharePath, firstManifest ? concat(of(firstManifest), dataIt) : dataIt);
    }
  }

  async refreshCache(request: AsyncIterableX<RefreshCacheRequest>): Promise<RefreshCacheReply> {
    try {
      await this.createManifestsFromSource(request);

      return { code: StatusCode.Ok };
    } catch (err) {
      return { code: StatusCode.Failed, message: err.message };
    }
  }

  async refreshCache2(request: AsyncIterableX<RefreshCacheRequest>): Promise<RefreshCacheReply> {
    try {
      let sharePath: Buffer | undefined;
      let it: CreateManifestAsyncIterable | undefined;

      do {
        if (sharePath && it) {
          await this.createManifestForSharePath(sharePath, it);
          sharePath = it?.lastHeader?.sharePath;
        }
        if (sharePath) {
          it = new CreateManifestAsyncIterable(it.lastFileManifest, request);
        } else {
          const nextValue = await request[Symbol.asyncIterator]().next();
          if (nextValue?.done) {
            break;
          }
          const { header, manifest } = nextValue?.value;
          if (header?.sharePath) {
            sharePath = header.sharePath;
            it = new CreateManifestAsyncIterable(manifest, request);
          }
        }
      } while (true);

      return { code: StatusCode.Ok };
    } catch (err) {
      return { code: StatusCode.Failed, message: err.message };
    }
  }

  launchBackup(share: Share): AsyncIterableX<LaunchBackupReply> {
    const manifest = new Manifest(\`backups.\${mangle(share.sharePath)}\`, '/tmp/');

    const createIndex$ = from(this.manifestService.loadIndex(manifest));

    const addEntryToIndex$ = createIndex$.pipe(
      map((index) =>
        this.fileReader.getFiles(
          index,
          share.sharePath,
          share.includes?.map((s) => globStringToRegex(s.toString('latin1'))),
          share.excludes?.map((s) => globStringToRegex(s.toString('latin1'))),
        ),
      ),
      concatAll(),
      map((entry) => this.manifestService.toAddJournalEntry(entry, true)),
      map((entry) => ({ entry, response: undefined })),
    );

    const addRemoveToIndex$ = createIndex$.pipe(
      map((index) => from(index.walk())),
      concatAll(),
      filter((entry) => !entry.markViewed),
      map((file) => this.manifestService.toRemoveJournalEntry(file.path)),
      map((entry) => ({ entry, response: undefined })),
    );

    const entries$ = concat(
      addEntryToIndex$,
      addRemoveToIndex$,
      of({ entry: undefined, response: { code: StatusCode.Ok } }),
    );

    return entries$.pipe(
      catchError((err) => {
        return of({
          entry: undefined,
          response: { code: StatusCode.Failed, message: err.message },
        });
      }),
    );
  }

  getChunk(request: ChunkInformation & { failIfWrongHash?: boolean }): AsyncIterableX<FileChunk> {
    const { filename, position, size, sha256 } = request;
    const stream: ReadStream = createReadStream(filename, {
      start: position.toNumber(),
      end: position.add(size).sub(1).toNumber(),
    });
    const hashReader = new FileHashReader();

    return from(
      pipeline(stream, hashReader, (err) => {
        // Nothing to do
      }),
    ).pipe(
      map((data) => ({ data })),
      finalize(() => {
        if (request.failIfWrongHash && sha256 && hashReader.hash && !hashReader.hash.equals(sha256)) {
          const message = \`The chunk \${filename.toString()}:\${position}:\${size} should have a sha of \${sha256.toString(
            'hex',
          )}, but is \${hashReader.hash.toString('hex')}\`;
          this.logger.warn(message);
          throw new InternalServerErrorException(message);
        }
      }),
    );
  }
}
",
]
`;

exports[`BackupContext LaunchBackup but return an error: Launch backup (normal) 1`] = `
Array [
  Object {
    "entry": undefined,
    "response": Object {
      "code": 1,
      "message": "Can't read files",
    },
  },
]
`;

exports[`BackupContext LaunchBackup should make backup with index (remove elements): Launch backup (normal) 1`] = `
Array [
  Object {
    "entry": Object {
      "manifest": Object {
        "chunks": Array [
          Object {
            "data": Array [
              120,
              33,
              153,
              168,
              222,
              33,
              57,
              10,
              128,
              77,
              242,
              219,
              140,
              195,
              8,
              196,
              216,
              150,
              108,
              16,
              225,
              129,
              162,
              82,
              249,
              106,
              243,
              92,
              81,
              233,
              104,
              47,
            ],
            "type": "Buffer",
          },
          Object {
            "data": Array [
              74,
              134,
              2,
              226,
              188,
              159,
              62,
              185,
              247,
              68,
              218,
              49,
              176,
              225,
              171,
              245,
              71,
              64,
              35,
              233,
              74,
              139,
              186,
              151,
              236,
              245,
              68,
              245,
              120,
              55,
              47,
              255,
            ],
            "type": "Buffer",
          },
        ],
        "path": Object {
          "data": Array [
            47,
            52,
            50,
            48,
            57,
            51,
            95,
            88,
            95,
            72,
            111,
            116,
            32,
            82,
            111,
            100,
            46,
            112,
            100,
            102,
          ],
          "type": "Buffer",
        },
        "sha256": Object {
          "data": Array [
            70,
            180,
            117,
            199,
            3,
            198,
            57,
            242,
            28,
            114,
            93,
            175,
            30,
            237,
            25,
            58,
            177,
            234,
            102,
            160,
            105,
            2,
            139,
            81,
            46,
            11,
            202,
            96,
            83,
            62,
            3,
            124,
          ],
          "type": "Buffer",
        },
        "stats": Object {
          "created": Long {
            "high": 376,
            "low": 1271037455,
            "unsigned": false,
          },
          "groupId": Long {
            "high": 0,
            "low": 1000,
            "unsigned": false,
          },
          "lastModified": Long {
            "high": 371,
            "low": 1656647184,
            "unsigned": false,
          },
          "lastRead": Long {
            "high": 372,
            "low": 1063485888,
            "unsigned": false,
          },
          "mode": Long {
            "high": 0,
            "low": 33188,
            "unsigned": false,
          },
          "ownerId": Long {
            "high": 0,
            "low": 1000,
            "unsigned": false,
          },
          "size": Long {
            "high": 0,
            "low": 4503209,
            "unsigned": false,
          },
        },
      },
      "type": 0,
    },
    "response": undefined,
  },
  Object {
    "entry": Object {
      "manifest": Object {
        "acl": Array [],
        "chunks": Array [],
        "path": Object {
          "data": Array [
            47,
            102,
            105,
            99,
            104,
            105,
            101,
            114,
            32,
            115,
            117,
            112,
            112,
            114,
            105,
            109,
            195,
            169,
            46,
            112,
            100,
            102,
          ],
          "type": "Buffer",
        },
        "stats": undefined,
        "xattr": Object {},
      },
      "type": 2,
    },
    "response": undefined,
  },
  Object {
    "entry": undefined,
    "response": Object {
      "code": 0,
    },
  },
]
`;

exports[`BackupContext LaunchBackup should make backup: Launch backup (normal) 1`] = `
Array [
  Object {
    "entry": Object {
      "manifest": Object {
        "chunks": Array [
          Object {
            "data": Array [
              120,
              33,
              153,
              168,
              222,
              33,
              57,
              10,
              128,
              77,
              242,
              219,
              140,
              195,
              8,
              196,
              216,
              150,
              108,
              16,
              225,
              129,
              162,
              82,
              249,
              106,
              243,
              92,
              81,
              233,
              104,
              47,
            ],
            "type": "Buffer",
          },
          Object {
            "data": Array [
              74,
              134,
              2,
              226,
              188,
              159,
              62,
              185,
              247,
              68,
              218,
              49,
              176,
              225,
              171,
              245,
              71,
              64,
              35,
              233,
              74,
              139,
              186,
              151,
              236,
              245,
              68,
              245,
              120,
              55,
              47,
              255,
            ],
            "type": "Buffer",
          },
        ],
        "path": Object {
          "data": Array [
            47,
            52,
            50,
            48,
            57,
            51,
            95,
            88,
            95,
            72,
            111,
            116,
            32,
            82,
            111,
            100,
            46,
            112,
            100,
            102,
          ],
          "type": "Buffer",
        },
        "sha256": Object {
          "data": Array [
            70,
            180,
            117,
            199,
            3,
            198,
            57,
            242,
            28,
            114,
            93,
            175,
            30,
            237,
            25,
            58,
            177,
            234,
            102,
            160,
            105,
            2,
            139,
            81,
            46,
            11,
            202,
            96,
            83,
            62,
            3,
            124,
          ],
          "type": "Buffer",
        },
        "stats": Object {
          "created": Long {
            "high": 376,
            "low": 1271037455,
            "unsigned": false,
          },
          "groupId": Long {
            "high": 0,
            "low": 1000,
            "unsigned": false,
          },
          "lastModified": Long {
            "high": 371,
            "low": 1656647184,
            "unsigned": false,
          },
          "lastRead": Long {
            "high": 372,
            "low": 1063485888,
            "unsigned": false,
          },
          "mode": Long {
            "high": 0,
            "low": 33188,
            "unsigned": false,
          },
          "ownerId": Long {
            "high": 0,
            "low": 1000,
            "unsigned": false,
          },
          "size": Long {
            "high": 0,
            "low": 4503209,
            "unsigned": false,
          },
        },
      },
      "type": 0,
    },
    "response": undefined,
  },
  Object {
    "entry": undefined,
    "response": Object {
      "code": 0,
    },
  },
]
`;
