// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`BackupOnClientService #RefreshCache #RefreshCache should create error: RefreshCacheReply 1`] = `
{
  "code": 1,
  "message": "Should be return error",
}
`;

exports[`BackupOnClientService #RefreshCache #RefreshCache should create one manifest from scratch : RefreshCacheReply 1`] = `
{
  "code": 0,
}
`;

exports[`BackupOnClientService #RefreshCache #RefreshCache should create two manifest from scratch : RefreshCacheReply 1`] = `
{
  "code": 0,
}
`;

exports[`BackupOnClientService #getChunk download a file, piece of file: getChunk 1`] = `
[
  "adRequestException, Injectable",
]
`;

exports[`BackupOnClientService #getChunk download a file: getChunk 1`] = `
[
  "import { BadRequestException, Injectable, Logger } from '@nestjs/common';
import { ExecuteCommandService, globStringToRegex, mangle, notUndefined, split } from '@woodstock/core';
import { createReadStream, ReadStream } from 'fs';
import { AsyncIterableX, concat, from, of } from 'ix/asynciterable';
import { catchError, concatAll, filter, finalize, map } from 'ix/asynciterable/operators';
import { Manifest, ManifestService } from '../manifest';
import {
  ChunkInformation,
  ExecuteCommandReply,
  FileChunk,
  FileManifest,
  LaunchBackupReply,
  RefreshCacheReply,
  RefreshCacheRequest,
  Share,
  StatusCode,
} from '../protobuf/woodstock.interface';
import { FileHashReader, FileReaderService } from '../scanner';

@Injectable()
export class BackupOnClientService {
  private logger = new Logger(BackupOnClientService.name);

  constructor(
    private commandService: ExecuteCommandService,
    private fileReader: FileReaderService,
    private manifestService: ManifestService,
  ) {}

  async executeCommand(command: string): Promise<ExecuteCommandReply> {
    return this.commandService.executeCommand(command);
  }

  private async createManifestForSharePath(sharePath: Buffer, source: AsyncIterable<FileManifest | undefined>) {
    const manifest = new Manifest(\`backups.\${mangle(sharePath)}\`, '/tmp/');
    await this.manifestService.deleteManifest(manifest);

    const entries$ = from(source).pipe(
      notUndefined<FileManifest>(),
      map((fileManifest) => ManifestService.toAddJournalEntry(fileManifest, true)),
    );
    await this.manifestService.writeJournalEntry(entries$, manifest);

    await this.manifestService.compact(manifest);
  }

  private async createManifestsFromSource(request: AsyncIterableX<RefreshCacheRequest>) {
    this.logger.log(\`Start creating manifests from source\`);

    const isHeader = (v: RefreshCacheRequest) => v.header?.sharePath;
    const groupOfManifest = request.pipe(split(isHeader));

    for await (const group of groupOfManifest) {
      const sharePath = group.key;
      const manifests = group.iterable.pipe(
        map((v) => v.fileManifest),
        notUndefined(),
      );

      await this.createManifestForSharePath(sharePath, manifests);
    }
  }

  async refreshCache(request: AsyncIterableX<RefreshCacheRequest>): Promise<RefreshCacheReply> {
    try {
      await this.createManifestsFromSource(request);

      return { code: StatusCode.Ok };
    } catch (err) {
      return { code: StatusCode.Failed, message: err.message };
    }
  }

  launchBackup(share: Share): AsyncIterableX<LaunchBackupReply> {
    const manifest = new Manifest(\`backups.\${mangle(share.sharePath)}\`, '/tmp/');

    const createIndex$ = from(this.manifestService.loadIndex(manifest));

    const addEntryToIndex$ = createIndex$.pipe(
      map((index) =>
        this.fileReader.getFiles(
          index,
          share.sharePath,
          share.includes?.map((s) => globStringToRegex(s.toString('latin1'))),
          share.excludes?.map((s) => globStringToRegex(s.toString('latin1'))),
        ),
      ),
      concatAll(),
      map((entry) => ({ entry, response: undefined })),
    );

    const addRemoveToIndex$ = createIndex$.pipe(
      map((index) => from(index.walk())),
      concatAll(),
      filter((entry) => !entry.markViewed),
      map((file) => ManifestService.toRemoveJournalEntry(file.path)),
      map((entry) => ({ entry, response: undefined })),
    );

    const entries$ = concat(
      addEntryToIndex$,
      addRemoveToIndex$,
      of({ entry: undefined, response: { code: StatusCode.Ok } }),
    );

    return entries$.pipe(
      catchError((err) => {
        return of({
          entry: undefined,
          response: { code: StatusCode.Failed, message: err.message },
        });
      }),
    );
  }

  getChunk(request: ChunkInformation & { failIfWrongHash?: boolean }): AsyncIterableX<FileChunk> {
    const { filename, position, size, sha256 } = request;
    this.logger.debug(\`Get the chunk \${filename} at position \${position} (size: \${size})\`);

    const stream: ReadStream = createReadStream(filename, {
      start: position.toNumber(),
      end: position.add(size).sub(1).toNumber(),
    });
    const hashReader = new FileHashReader();

    stream.pipe(hashReader);
    stream.on('error', (err) => {
      hashReader.emit('error', err);
      hashReader.end();
      stream.close();
    });
    hashReader.on('error', () => {
      hashReader.end();
      stream.close();
    });

    return from(hashReader).pipe(
      map((data) => ({ data })),
      finalize(() => {
        if (request.failIfWrongHash && sha256 && hashReader.hash && !hashReader.hash.equals(sha256)) {
          const message = \`The chunk \${filename.toString()}:\${position}:\${size} should have a sha of \${sha256.toString(
            'hex',
          )}, but is \${hashReader.hash.toString('hex')}\`;
          this.logger.warn(message);

          throw new BadRequestException(message);
        }
      }),
    );
  }
}
",
]
`;

exports[`BackupOnClientService LaunchBackup but return an error: Launch backup (normal) 1`] = `
[
  {
    "entry": undefined,
    "response": {
      "code": 1,
      "message": "Can't read files",
    },
  },
]
`;

exports[`BackupOnClientService LaunchBackup should make backup with index (remove elements): Launch backup (normal) 1`] = `
[
  {
    "entry": {
      "chunks": [
        {
          "data": [
            120,
            33,
            153,
            168,
            222,
            33,
            57,
            10,
            128,
            77,
            242,
            219,
            140,
            195,
            8,
            196,
            216,
            150,
            108,
            16,
            225,
            129,
            162,
            82,
            249,
            106,
            243,
            92,
            81,
            233,
            104,
            47,
          ],
          "type": "Buffer",
        },
        {
          "data": [
            74,
            134,
            2,
            226,
            188,
            159,
            62,
            185,
            247,
            68,
            218,
            49,
            176,
            225,
            171,
            245,
            71,
            64,
            35,
            233,
            74,
            139,
            186,
            151,
            236,
            245,
            68,
            245,
            120,
            55,
            47,
            255,
          ],
          "type": "Buffer",
        },
      ],
      "path": {
        "data": [
          47,
          52,
          50,
          48,
          57,
          51,
          95,
          88,
          95,
          72,
          111,
          116,
          32,
          82,
          111,
          100,
          46,
          112,
          100,
          102,
        ],
        "type": "Buffer",
      },
      "sha256": {
        "data": [
          70,
          180,
          117,
          199,
          3,
          198,
          57,
          242,
          28,
          114,
          93,
          175,
          30,
          237,
          25,
          58,
          177,
          234,
          102,
          160,
          105,
          2,
          139,
          81,
          46,
          11,
          202,
          96,
          83,
          62,
          3,
          124,
        ],
        "type": "Buffer",
      },
      "stats": {
        "created": Long {
          "high": 376,
          "low": 1271037455,
          "unsigned": false,
        },
        "groupId": Long {
          "high": 0,
          "low": 1000,
          "unsigned": false,
        },
        "lastModified": Long {
          "high": 371,
          "low": 1656647184,
          "unsigned": false,
        },
        "lastRead": Long {
          "high": 372,
          "low": 1063485888,
          "unsigned": false,
        },
        "mode": Long {
          "high": 0,
          "low": 33188,
          "unsigned": false,
        },
        "ownerId": Long {
          "high": 0,
          "low": 1000,
          "unsigned": false,
        },
        "size": Long {
          "high": 0,
          "low": 4503209,
          "unsigned": false,
        },
      },
    },
    "response": undefined,
  },
  {
    "entry": {
      "manifest": {
        "acl": [],
        "chunks": [],
        "path": {
          "data": [
            47,
            102,
            105,
            99,
            104,
            105,
            101,
            114,
            32,
            115,
            117,
            112,
            112,
            114,
            105,
            109,
            195,
            169,
            46,
            112,
            100,
            102,
          ],
          "type": "Buffer",
        },
        "stats": undefined,
        "xattr": {},
      },
      "type": 2,
    },
    "response": undefined,
  },
  {
    "entry": undefined,
    "response": {
      "code": 0,
    },
  },
]
`;

exports[`BackupOnClientService LaunchBackup should make backup: Launch backup (normal) 1`] = `
[
  {
    "entry": {
      "chunks": [
        {
          "data": [
            120,
            33,
            153,
            168,
            222,
            33,
            57,
            10,
            128,
            77,
            242,
            219,
            140,
            195,
            8,
            196,
            216,
            150,
            108,
            16,
            225,
            129,
            162,
            82,
            249,
            106,
            243,
            92,
            81,
            233,
            104,
            47,
          ],
          "type": "Buffer",
        },
        {
          "data": [
            74,
            134,
            2,
            226,
            188,
            159,
            62,
            185,
            247,
            68,
            218,
            49,
            176,
            225,
            171,
            245,
            71,
            64,
            35,
            233,
            74,
            139,
            186,
            151,
            236,
            245,
            68,
            245,
            120,
            55,
            47,
            255,
          ],
          "type": "Buffer",
        },
      ],
      "path": {
        "data": [
          47,
          52,
          50,
          48,
          57,
          51,
          95,
          88,
          95,
          72,
          111,
          116,
          32,
          82,
          111,
          100,
          46,
          112,
          100,
          102,
        ],
        "type": "Buffer",
      },
      "sha256": {
        "data": [
          70,
          180,
          117,
          199,
          3,
          198,
          57,
          242,
          28,
          114,
          93,
          175,
          30,
          237,
          25,
          58,
          177,
          234,
          102,
          160,
          105,
          2,
          139,
          81,
          46,
          11,
          202,
          96,
          83,
          62,
          3,
          124,
        ],
        "type": "Buffer",
      },
      "stats": {
        "created": Long {
          "high": 376,
          "low": 1271037455,
          "unsigned": false,
        },
        "groupId": Long {
          "high": 0,
          "low": 1000,
          "unsigned": false,
        },
        "lastModified": Long {
          "high": 371,
          "low": 1656647184,
          "unsigned": false,
        },
        "lastRead": Long {
          "high": 372,
          "low": 1063485888,
          "unsigned": false,
        },
        "mode": Long {
          "high": 0,
          "low": 33188,
          "unsigned": false,
        },
        "ownerId": Long {
          "high": 0,
          "low": 1000,
          "unsigned": false,
        },
        "size": Long {
          "high": 0,
          "low": 4503209,
          "unsigned": false,
        },
      },
    },
    "response": undefined,
  },
  {
    "entry": undefined,
    "response": {
      "code": 0,
    },
  },
]
`;
