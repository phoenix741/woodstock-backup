syntax = "proto3";

package woodstock;

message PoolRefCount {
  bytes sha256 = 1;
  int32 refCount = 2;
  int32 size = 3;
  int32 compressedSize = 4;
}

// Status Code for reply
enum StatusCode {
  Ok = 0;
  Failed = 1;
  Partial = 2;
}

message FileManifestStat {
  optional int64 ownerId = 1;
  optional int64 groupId = 2;
  optional int64 size = 3;
  optional int64 compressedSize = 8;
  optional int64 lastRead = 4;
  optional int64 lastModified = 5;
  optional int64 created = 6;
  optional int64 mode = 7;

  optional int64 dev = 9;
  optional int64 rdev = 10;

  optional int64 ino = 11;
  optional int64 nlink = 12;
}

message FileManifestAcl {
  optional string user = 1;
  optional string group = 2;
  optional int32 mask = 3;
  optional int32 other = 4;
}

// File manifest used to store the content of a file
message FileManifest {
  bytes path = 1;
  FileManifestStat stats = 2;
  map<string, bytes> xattr = 5;
  repeated FileManifestAcl acl = 6;
  repeated bytes chunks = 3;
  optional bytes sha256 = 4;
  optional bytes symlink = 7;
}

enum EntryType {
  // Add a new file
  ADD = 0;
  // Modify a file
  MODIFY = 1;
  // Remove a file
  REMOVE = 2;
}

// Journal entry
message FileManifestJournalEntry {
  EntryType type = 1;
  FileManifest manifest = 2;
}

enum LogLevel {
  log = 0;
  error = 1;
  warn = 2;
  debug = 3;
  verbose = 4;
}

// Log entry
message LogEntry {
  LogLevel level = 1;
  string context = 2;
  string line = 3;
}

message RefreshCacheHeader {
  bytes sharePath = 1;
}

message RefreshCacheRequest {
  RefreshCacheHeader header = 1;
  FileManifest fileManifest = 2;
}

message RefreshCacheReply {
  StatusCode code = 1;
  optional string message = 2;
}

message LaunchBackupRequest {
  Share share = 1;
}

message LaunchBackupResponse {
  StatusCode code = 1;
  optional string message = 2;
}

message LaunchBackupReply {
  FileManifestJournalEntry entry = 2;
  LaunchBackupResponse response = 3;
}

message ChunkInformation {
  bytes filename = 1;
  uint64 position = 2;
  uint64 size = 3;
  optional bytes sha256 = 4;
}

message FileChunk {
  bytes data = 1;
}

message GetChunkRequest {
  ChunkInformation chunk = 1;
}

enum ChunkStatus {
  DATA = 0;
  ERROR = 1;
}

message GetChunkReply {
  ChunkStatus status = 1;
  FileChunk data = 3;
}

message StreamLogRequest {
}

message ExecuteCommandRequest {
  string command = 1;
}

message ExecuteCommandReply {
  int32 code = 1;
  string stdout = 2;
  string stderr = 3;
}

message Share {
  bytes sharePath = 1;
  repeated bytes includes = 2;
  repeated bytes excludes = 3;
}

message AuthenticateRequest {
  uint32 version = 1;
}

message AuthenticateReply {
  StatusCode code = 1;
  optional string message = 2;
  optional string sessionId = 3;
}

service WoodstockClientService {
  // 0. Authenticate
  rpc Authenticate(AuthenticateRequest) returns (AuthenticateReply);

  // 1. Execute a command directly on the client
  rpc ExecuteCommand(ExecuteCommandRequest) returns (ExecuteCommandReply) {}

  // 2. The server send the last cache version to the client
  rpc RefreshCache(stream RefreshCacheRequest) returns (RefreshCacheReply) {}

  // 3. The server launch the backup with a new number. The client will browse the client computer
  //    and will send all new file to the server
  rpc LaunchBackup(LaunchBackupRequest) returns (stream LaunchBackupReply) {}

  // 3. When the server receive a journal entry, the server will compare the chunk with the manifest
  //    and ask all necessary chunk to the client.
  rpc GetChunk(GetChunkRequest) returns (stream GetChunkReply) {}

  // In parallele, the server will open a stream for the client to send log file.
  rpc StreamLog(StreamLogRequest) returns (stream LogEntry) {}
}
